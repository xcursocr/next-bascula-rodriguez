### Crear el proyecto y dependencias

```bash
# Crear Next.js 15 con TypeScript
npx create-next-app@latest my-scale-store --ts

cd my-scale-store

# Instalar Convex y utilidades
npm install convex
npx convex dev   # Inicializa carpeta convex/ y arranca backend local

# Si vamos a usar ESLint + Prettier para orden
npm install -D eslint prettier
```

### Estructura de carpetas sugerida

```bash
/app
  /admin
    /products
      page.tsx
      edit/[id]/page.tsx
  layout.tsx
  page.tsx
/components
  AdminProductForm.tsx
  ImageUploader.tsx
/lib
  convexClient.ts
  paypal.ts
/convex
  mutations/
    products.ts
    files.ts
  queries/
    products.ts
  schema.ts
/pages/api
  /paypal
    create-order.ts
    capture-order.ts
```

### Cliente Convex en Next.js (/lib/convexClient.ts)

```ts
"use client";

import { ConvexProvider, ConvexReactClient } from "convex/react";
import { ReactNode } from "react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ProviderConvex({ children }: { children: ReactNode }) {
  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
}

```

### Inportar provider layout (/layout.tsx)

```tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { ProviderConvex } from "@/providers/ProviderConvex";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="es" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ProviderConvex>{children}</ProviderConvex>
      </body>
    </html>
  );
}
```

### Definir esquema Convex (/convex/schema.ts)

```ts
import { defineSchema, defineTable } from "convex/schema";
import { v } from "convex/values";

export default defineSchema({
  products: defineTable({
    title: v.string(),
    slug: v.string(),
    description: v.string(),
    price_cents: v.number(),
    currency: v.string(),
    categoryId: v.id("categories"),
    colorIds: v.array(v.id("colors")),
    sizeIds: v.array(v.id("sizes")),
    featureIds: v.array(v.id("features")),
    imageStorageIds: v.array(v.string()), // storageId de Convex
    stock: v.number(),
    status: v.string(),
    createdAt: v.number(),
    updatedAt: v.number(),
  }),
  categories: defineTable({
    name: v.string(),
    slug: v.string(),
    description: v.string(),
    imageStorageId: v.optional(v.string()),
  }),
  colors: defineTable({
    name: v.string(),
    hex: v.string(),
  }),
  sizes: defineTable({
    name: v.string(),
    measureUnit: v.string(),
  }),
  features: defineTable({
    name: v.string(),
    valueType: v.string(),
    unit: v.optional(v.string()),
  }),
});
```

### Mutaciones base /convex/mutations/products.ts

```ts
import { mutation } from "../_generated/server";
import { v } from "convex/values";

export const createProduct = mutation({
  args: {
    title: v.string(),
    slug: v.string(),
    description: v.string(),
    price_cents: v.number(),
    currency: v.string(),
    categoryId: v.id("categories"),
    colorIds: v.array(v.id("colors")),
    sizeIds: v.array(v.id("sizes")),
    featureIds: v.array(v.id("features")),
    imageStorageIds: v.array(v.string()),
    stock: v.number(),
    status: v.string(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    return await ctx.db.insert("products", {
      ...args,
      createdAt: now,
      updatedAt: now,
    });
  },
});
```

### /convex/mutations/files.ts

```ts
import { mutation } from "../_generated/server";
import { v } from "convex/values";

export const generateUploadUrl = mutation({
  args: {
    filename: v.string(),
    contentType: v.string(),
  },
  handler: async (ctx, { filename, contentType }) => {
    const { uploadUrl, storageId } = await ctx.storage.generateUploadUrl({
      contentType,
      // puedes definir tamaño máximo, etc.
    });
    return { uploadUrl, storageId };
  },
});
```

### Query para listar productos /convex/queries/products.ts

```ts
import { query } from "../_generated/server";

export const listProducts = query(async (ctx) => {
  return await ctx.db.query("products").order("desc").collect();
});
```

### Componente de subida de imágenes (/components/ImageUploader.tsx)

```tsx
"use client";
import { useMutation } from "convex/react";
import React, { useState } from "react";

export default function ImageUploader({
  onUploaded,
}: {
  onUploaded: (id: string) => void;
}) {
  const [file, setFile] = useState<File | null>(null);
  const generateUrl = useMutation("files:generateUploadUrl");

  const handleUpload = async () => {
    if (!file) return;
    const { uploadUrl, storageId } = await generateUrl({
      filename: file.name,
      contentType: file.type,
    });
    await fetch(uploadUrl, { method: "POST", body: file });
    onUploaded(storageId);
  };

  return (
    <div>
      <input
        type="file"
        onChange={(e) => setFile(e.target.files?.[0] || null)}
      />
      <button onClick={handleUpload} disabled={!file}>
        Subir
      </button>
    </div>
  );
}
```

### Formulario de producto (/components/AdminProductForm.tsx)

```tsx
"use client";
import { useMutation } from "convex/react";
import { useState } from "react";
import ImageUploader from "./ImageUploader";

export default function AdminProductForm() {
  const createProduct = useMutation("products:createProduct");
  const [title, setTitle] = useState("");
  const [slug, setSlug] = useState("");
  const [price, setPrice] = useState<number>(0);
  const [currency, setCurrency] = useState("USD");
  const [imageIds, setImageIds] = useState<string[]>([]);

  const onSubmit = async () => {
    await createProduct({
      title,
      slug,
      description: "",
      price_cents: price * 100,
      currency,
      categoryId: "someCategoryId" as any, // cambiar con un select real
      colorIds: [],
      sizeIds: [],
      featureIds: [],
      imageStorageIds: imageIds,
      stock: 0,
      status: "draft",
    });
  };

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        onSubmit();
      }}
    >
      <input
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="Título"
      />
      <input
        value={slug}
        onChange={(e) => setSlug(e.target.value)}
        placeholder="Slug"
      />
      <input
        type="number"
        value={price}
        onChange={(e) => setPrice(Number(e.target.value))}
        placeholder="Precio"
      />
      <ImageUploader onUploaded={(id) => setImageIds([...imageIds, id])} />
      <button type="submit">Guardar producto</button>
    </form>
  );
}
```

### Página admin de productos (/app/admin/products/page.tsx)

```tsx
import AdminProductForm from "@/components/AdminProductForm";

export default function ProductsAdminPage() {
  return (
    <div>
      <h1>Administrar Productos</h1>
      <AdminProductForm />
    </div>
  );
}
```

### Variables de entorno (archivo .env.local)

```env
NEXT_PUBLIC_CONVEX_URL="http://localhost:xxxx" # generado por convex dev
PAYPAL_CLIENT_ID="..."
PAYPAL_CLIENT_SECRET="..."
PAYPAL_BASE="https://api-m.sandbox.paypal.com"
```

#### Con este scaffold ya tienes:

1. Next.js 15 funcionando con Convex.

2. Modelo y mutaciones para productos y archivos.

3. Dashboard inicial con subida de imágenes al storage de Convex.

4. Preparado para añadir PayPal endpoints y lógica.

<!-- FASE 2 -->

### Mutaciones y queries para categorías, colores, tamaños /convex/mutations/categories.ts

```ts
import { mutation } from "../_generated/server";
import { v } from "convex/values";

export const createCategory = mutation({
  args: {
    name: v.string(),
    slug: v.string(),
    description: v.string(),
    imageStorageId: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("categories", args);
  },
});
```

### /convex/mutations/colors.ts

```ts
import { mutation } from "../_generated/server";
import { v } from "convex/values";

export const createColor = mutation({
  args: {
    name: v.string(),
    hex: v.string(),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("colors", args);
  },
});
```

### /convex/mutations/sizes.ts

```ts
import { mutation } from "../_generated/server";
import { v } from "convex/values";

export const createSize = mutation({
  args: {
    name: v.string(),
    measureUnit: v.string(),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("sizes", args);
  },
});
```

### Queries para listar /convex/queries/categories.ts

```ts
import { query } from "../_generated/server";

export const listCategories = query(async (ctx) => {
  return await ctx.db.query("categories").order("asc").collect();
});
```

### /convex/queries/colors.ts

```ts
import { query } from "../_generated/server";

export const listColors = query(async (ctx) => {
  return await ctx.db.query("colors").order("asc").collect();
});
```

### /convex/queries/sizes.ts

```ts
import { query } from "../_generated/server";

export const listSizes = query(async (ctx) => {
  return await ctx.db.query("sizes").order("asc").collect();
});
```

### Actualizar formulario de producto (/components/AdminProductForm.tsx)

```tsx
"use client";
import { useMutation, useQuery } from "convex/react";
import { useState } from "react";
import ImageUploader from "./ImageUploader";

export default function AdminProductForm() {
  const createProduct = useMutation("products:createProduct");

  // Queries para selects
  const categories = useQuery("categories:listCategories") || [];
  const colors = useQuery("colors:listColors") || [];
  const sizes = useQuery("sizes:listSizes") || [];

  const [title, setTitle] = useState("");
  const [slug, setSlug] = useState("");
  const [price, setPrice] = useState<number>(0);
  const [currency, setCurrency] = useState("USD");
  const [categoryId, setCategoryId] = useState<string>("");
  const [colorIds, setColorIds] = useState<string[]>([]);
  const [sizeIds, setSizeIds] = useState<string[]>([]);
  const [imageIds, setImageIds] = useState<string[]>([]);

  const onSubmit = async () => {
    await createProduct({
      title,
      slug,
      description: "",
      price_cents: price * 100,
      currency,
      categoryId: categoryId as any,
      colorIds: colorIds as any,
      sizeIds: sizeIds as any,
      featureIds: [],
      imageStorageIds: imageIds,
      stock: 0,
      status: "draft",
    });
    alert("Producto creado");
  };

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        onSubmit();
      }}
    >
      <input
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="Título"
      />
      <input
        value={slug}
        onChange={(e) => setSlug(e.target.value)}
        placeholder="Slug"
      />
      <input
        type="number"
        value={price}
        onChange={(e) => setPrice(Number(e.target.value))}
        placeholder="Precio"
      />
      <select value={currency} onChange={(e) => setCurrency(e.target.value)}>
        <option value="USD">USD</option>
        <option value="EUR">EUR</option>
      </select>

      <select
        value={categoryId}
        onChange={(e) => setCategoryId(e.target.value)}
      >
        <option value="">Selecciona categoría</option>
        {categories.map((cat) => (
          <option key={cat._id} value={cat._id}>
            {cat.name}
          </option>
        ))}
      </select>

      <label>Colores:</label>
      {colors.map((c) => (
        <label key={c._id}>
          <input
            type="checkbox"
            checked={colorIds.includes(c._id)}
            onChange={(e) => {
              setColorIds(
                e.target.checked
                  ? [...colorIds, c._id]
                  : colorIds.filter((id) => id !== c._id)
              );
            }}
          />
          {c.name}
        </label>
      ))}

      <label>Tamaños:</label>
      {sizes.map((s) => (
        <label key={s._id}>
          <input
            type="checkbox"
            checked={sizeIds.includes(s._id)}
            onChange={(e) => {
              setSizeIds(
                e.target.checked
                  ? [...sizeIds, s._id]
                  : sizeIds.filter((id) => id !== s._id)
              );
            }}
          />
          {s.name}
        </label>
      ))}

      <ImageUploader onUploaded={(id) => setImageIds([...imageIds, id])} />

      <button type="submit">Guardar producto</button>
    </form>
  );
}
```

### API PayPal en Next.js

#### /pages/api/paypal/create-order.ts

```ts
import type { NextApiRequest, NextApiResponse } from "next";

async function getAccessToken() {
  const auth = Buffer.from(
    process.env.PAYPAL_CLIENT_ID + ":" + process.env.PAYPAL_CLIENT_SECRET
  ).toString("base64");

  const res = await fetch(`${process.env.PAYPAL_BASE}/v1/oauth2/token`, {
    method: "POST",
    headers: {
      Authorization: `Basic ${auth}`,
      "Content-Type": "application/x-www-form-urlencoded",
    },
    body: "grant_type=client_credentials",
  });
  const data = await res.json();
  return data.access_token;
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== "POST") return res.status(405).end();

  const { total_cents, currency } = req.body;
  const accessToken = await getAccessToken();

  const orderRes = await fetch(
    `${process.env.PAYPAL_BASE}/v2/checkout/orders`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken}`,
      },
      body: JSON.stringify({
        intent: "CAPTURE",
        purchase_units: [
          {
            amount: {
              currency_code: currency,
              value: (total_cents / 100).toFixed(2),
            },
          },
        ],
      }),
    }
  );

  const data = await orderRes.json();
  res.status(200).json(data);
}
```

### /pages/api/paypal/capture-order.ts

```ts
import type { NextApiRequest, NextApiResponse } from "next";

async function getAccessToken() {
  const auth = Buffer.from(
    process.env.PAYPAL_CLIENT_ID + ":" + process.env.PAYPAL_CLIENT_SECRET
  ).toString("base64");

  const res = await fetch(`${process.env.PAYPAL_BASE}/v1/oauth2/token`, {
    method: "POST",
    headers: {
      Authorization: `Basic ${auth}`,
      "Content-Type": "application/x-www-form-urlencoded",
    },
    body: "grant_type=client_credentials",
  });
  const data = await res.json();
  return data.access_token;
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== "POST") return res.status(405).end();

  const { orderId } = req.body;
  const accessToken = await getAccessToken();

  const captureRes = await fetch(
    `${process.env.PAYPAL_BASE}/v2/checkout/orders/${orderId}/capture`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken}`,
      },
    }
  );

  const data = await captureRes.json();
  res.status(200).json(data);
}
```

### Variables de entorno .env.local

```env
NEXT_PUBLIC_CONVEX_URL="http://localhost:xxxx"
PAYPAL_CLIENT_ID="..."
PAYPAL_CLIENT_SECRET="..."
PAYPAL_BASE="https://api-m.sandbox.paypal.com"
```

#### Con esto ya puedes:

1. Crear categorías, colores y tamaños con mutaciones simples (puedes montar forms parecidos al de producto).

2. Relacionar producto con categorías, colores y tamaños desde el dashboard.

3. Crear y capturar órdenes de PayPal desde el frontend usando los endpoints /api/paypal/create-order y /api/paypal/capture-order.
